import { 
  collection, 
  addDoc, 
  getDocs, 
  doc, 
  updateDoc, 
  deleteDoc, 
  query, 
  where, 
  orderBy,
  limit,
  Timestamp,
  deleteField
} from 'firebase/firestore';
import { db } from './firebase';
import { Player, Match, MatchType } from '../types';

// Collections
const PLAYERS_COLLECTION = 'players';
const MATCHES_COLLECTION = 'matches';

// Helper function to convert Firestore timestamp to Date
const convertTimestamp = (timestamp: any): Date => {
  if (timestamp?.toDate) {
    return timestamp.toDate();
  }
  if (timestamp?.seconds) {
    return new Date(timestamp.seconds * 1000);
  }
  return new Date(timestamp);
};

// Players
export const addPlayer = async (player: Player, userId: string): Promise<string> => {
  try {
    const docRef = await addDoc(collection(db, PLAYERS_COLLECTION), {
      ...player,
      userId,
      createdAt: Timestamp.fromDate(player.createdAt)
    });
    return docRef.id;
  } catch (error) {
    console.error('Error adding player:', error);
    throw error;
  }
};

export const getPlayers = async (userId: string): Promise<Player[]> => {
  try {
    const q = query(
      collection(db, PLAYERS_COLLECTION),
      where('userId', '==', userId),
      orderBy('createdAt', 'desc')
    );
    const querySnapshot = await getDocs(q);
    
    return querySnapshot.docs.map(doc => ({
      ...doc.data(),
      id: doc.id,
      createdAt: convertTimestamp(doc.data().createdAt)
    })) as Player[];
  } catch (error) {
    console.error('Error getting players:', error);
    throw error;
  }
};

export const updatePlayer = async (playerId: string, updates: Partial<Player>): Promise<void> => {
  try {
    const playerRef = doc(db, PLAYERS_COLLECTION, playerId);
    await updateDoc(playerRef, updates);
  } catch (error) {
    console.error('Error updating player:', error);
    throw error;
  }
};

export const deletePlayer = async (playerId: string): Promise<void> => {
  try {
    await deleteDoc(doc(db, PLAYERS_COLLECTION, playerId));
  } catch (error) {
    console.error('Error deleting player:', error);
    throw error;
  }
};

// Matches
export const addMatch = async (match: Match, userId: string): Promise<string> => {
  try {
    const matchData = {
      ...match,
      userId,
      createdBy: userId, // explicitly set createdBy to the user creating the match
      date: Timestamp.fromDate(match.date), // Convert Date to Firestore Timestamp
      // Ensure isPublic is explicitly set, defaulting to false if not provided
      isPublic: typeof match.isPublic === 'boolean' ? match.isPublic : false,
      // Include matchType if it exists
      ...(match.matchType && { matchType: match.matchType }),
    };
    // Remove id from matchData as it's generated by Firestore
    const { id, ...matchDataForFirestore } = matchData;
    console.log('Saving match to Firestore with data:', JSON.stringify(matchDataForFirestore, null, 2));
    const docRef = await addDoc(collection(db, MATCHES_COLLECTION), matchDataForFirestore);
    return docRef.id;
  } catch (error) {
    console.error('Error adding match:', error);
    throw error;
  }
};

export const getMatches = async (userId: string): Promise<Match[]> => {
  try {
    const q = query(
      collection(db, MATCHES_COLLECTION),
      where('userId', '==', userId),
      orderBy('date', 'desc')
    );
    const querySnapshot = await getDocs(q);
    
    return querySnapshot.docs.map(doc => {
      const data = doc.data();
      return {
        ...data,
        id: doc.id,
        date: convertTimestamp(data.date),
        matchType: data.matchType as MatchType | undefined, // Cast if necessary, or handle if it might be missing
      } as Match;
    });
  } catch (error) {
    console.error('Error getting matches:', error);
    throw error;
  }
};

export const getPublicMatches = async (limitCount: number = 50): Promise<Match[]> => {
  try {
    const q = query(
      collection(db, MATCHES_COLLECTION),
      where('isPublic', '==', true),
      orderBy('date', 'desc'),
      limit(limitCount)
    );
    const querySnapshot = await getDocs(q);
    
    return querySnapshot.docs.map(doc => {
      const data = doc.data();
      return {
        ...data,
        id: doc.id,
        date: convertTimestamp(data.date),
        matchType: data.matchType as MatchType | undefined, // Cast if necessary
      } as Match;
    });
  } catch (error) {
    console.error('Error getting public matches:', error);
    throw error;
  }
};

export const updateMatch = async (matchId: string, updates: Partial<Match>): Promise<void> => {
  try {
    const matchRef = doc(db, MATCHES_COLLECTION, matchId);
    // Create a new object for Firestore data to avoid mutating the original 'updates' object
    const updateDataFirestore: any = { ...updates };

    // Convert Date to Timestamp if present
    if (updates.date && updates.date instanceof Date) {
      updateDataFirestore.date = Timestamp.fromDate(updates.date);
    } else if (updates.date) {
      // If it's not a Date object but is present, ensure it's a Timestamp or handle error
      // For simplicity, assuming valid Timestamp if not a Date. Production code might need more robust check.
      updateDataFirestore.date = updates.date;
    }
    
    // Handle winnerId specifically
    // If winnerId is explicitly undefined in updates, use deleteField to remove it from Firestore.
    // Otherwise, just include its value (it might be a string, or not present in the updates object).
    if (updates.hasOwnProperty('winnerId')) {
      if (updates.winnerId === undefined) {
        updateDataFirestore.winnerId = deleteField();
      } else {
        updateDataFirestore.winnerId = updates.winnerId;
      }
    }

    // If teams are being updated, ensure they are in a format Firestore can handle (e.g. array of objects)
    // This part assumes 'teams' structure is already correct as per 'Match' type
    if (updates.teams) {
        updateDataFirestore.teams = updates.teams;
    }

    // Handle matchType update
    if (updates.hasOwnProperty('matchType')) {
      if (updates.matchType === undefined || updates.matchType === null) {
        updateDataFirestore.matchType = deleteField(); // Or set to null if preferred: updateDataFirestore.matchType = null;
      } else {
        updateDataFirestore.matchType = updates.matchType;
      }
    }

    console.log('Updating match with Firestore data:', JSON.stringify(updateDataFirestore));
    await updateDoc(matchRef, updateDataFirestore);
  } catch (error) {
    console.error('Error updating match:', error);
    throw error;
  }
};

export const deleteMatch = async (matchId: string): Promise<void> => {
  try {
    await deleteDoc(doc(db, MATCHES_COLLECTION, matchId));
  } catch (error) {
    console.error('Error deleting match:', error);
    throw error;
  }
};